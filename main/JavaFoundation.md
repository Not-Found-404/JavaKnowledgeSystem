# Java基础

## <a href="https://github.com/wildhunt-unique/JavaKnowledgePoint/blob/master/README.md">返回概览</a>

+ 参考资料
    + > 深入理解Java虚拟机：JVM高级特性与最佳实践 / 周志明著 -2版- 

+ Java内存模型(**重中之重**)
    + JMM(Java Memory Model)，Java虚拟机在执行Java程序的过程会把它所管理的内存划分为若干不同的区域。这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机的启动而存在，有的区域则依赖用户线程的启动和结束来创建
    + JMM运行时数据区如图所示
    + ![Image text](http://www.qtu404.com/imageLib/github/20180625095148.png)
    + Java运行时数据区分为以下几个部分
        + 线程共享的部分
            + 方法区
            + 堆

        + 线程私有的部分
            + 虚拟机栈
            + 本地方法栈
            + 程序计数器

    + 程序计算器(Program Counter Register)
        + 程序计数器是一块较小的线程私有的内存空间，可以看作是当前线程锁执行的字节码的行号指示器。字节码解释器工作时，就参考这个数值来选取下一条执行的指令，分支、循环、跳转、异常处理、线程回复都等基础功能都要需要依赖这个计数器来完成。

        + Java通过线程轮换并分配处理器执行时间来实现多线程。因此，在一个确定的时刻，一个处理器都只会执行一条线程的指令。为了在切换线程之后，各线程都能恢复到正确的执行位置，每个线程都要需要一个独立的计数器。各个线程的计数器都互不影响，独立存储。为“线程私有”的内存。

        +  如果线程正在执行的是一个Java方法，记录的是正在执行的虚拟机字节码指令的地址

        +  如果执行的是Native方法，计数器值为空（Undefined）

        +  程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

    + Java虚拟机栈(Java Virtaul Machine Stacks)
        + Java虚拟栈也是线程私有的内存。其生命周期与线程相同，虚拟栈描述的是**Java方法**执行的内存模型。每个方法在执行的时候，都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的调用、执行和结束，都对应着栈帧在虚拟机栈入栈、出栈的过程。

        + 在规范中，此区域规定了两种异常。
            + 如果线程请求栈的深度大于虚拟机所允许的深度，则会抛出StackOverflowError异常
            + 如果栈可以动态扩展，当时扩展时，没有申请到足够的内存，就会抛出 OutOfMemoryError异常

    + 本地方法栈(Native Method Stack)
        + 与Java虚拟机栈功能相同，不同的是，Java虚拟机栈为虚拟机执行Java方法(.class字节码)服务，而本地方法栈为Native方法服务。什么是Native方法，自行百度JNI。

        + 值得注意的是，我们默认使用的JVM —— SunHotSpot，直接把 本地方法栈 和 Java虚拟机栈合二为一。同样会抛出StackOverflowError异常和OutOfMemoryError异常

    + Java堆(Java Heap)
        + Java堆是线程共享的区域，也是JMM中最大的一块。用于存放对象的实例以及数组，几乎所有的对象实例都在堆这里分配。注意是几乎，而不是绝对。

        + 由于此区域存放对象的实例。因此，java堆也是垃圾收集的主要区域。又由于现在的垃圾收集器都基于分代收集算法，所以Java堆还可以细分为新生代和老年代，再细致点，还可以向下再分为Eden空间、From Survivor空间、ToSurvivor空间等。关于这部分的详细知识，会在后面的GC部分详细描述。

        + 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。

    + 方法区(Medth Area)
        + 和堆一样，是各个线程共享的区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译的数据等。

        + Java虚拟机规范中将方法区作为堆的一个逻辑部分。 由于存放类的信息、常量、静态变量等数据，这些数据可能都是长时间驻存在内存中的，而且一个类是否应该被垃圾收集是不容易确认的，因此方法区中的数据不易被垃圾收集。
        
        + 习惯在Hotspot虚拟机上编程的程序来说，方法区还习惯被称“永久代”，但是这么说是有错误的。因为HopSpot只是用“永久代”来实现方法区。
+ GC垃圾收集(**重中之重**)

+ 多态（重载重写）

+ object方法

+ 类访问权限

+ sleep、notify、wait 联系、区别

+ String、stringbuffer、stringbuilder 联系、区别、源码

+ Volatile 原理、源码、与syn区别
    + 关键字volatile是JVM中最轻量的同步机制。volatile变量具有2种特性：
        + 保证变量的可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入，这个新值对于其他线程来说是立即可见的。
        + 屏蔽指令重排序：指令重排序是编译器和处理器为了高效对程序进行优化的手段，下文有详细的分析。

    + volatile语义并不能保证变量的原子性。对任意单个volatile变量的读/写具有原子性，但类似于i++、i–这种复合操作不具有原子性，因为自增运算包括读取i的值、i值增加1、重新赋值3步操作，并不具备原子性。

    + 由于volatile只能保证变量的可见性和屏蔽指令重排序，只有满足下面2条规则时，才能使用volatile来保证并发安全，否则就需要加锁（使用synchronized、lock或者java.util.concurrent中的Atomic原子类）来保证并发中的原子性。
        + 运算结果不存在数据依赖（重排序的数据依赖性），或者只有单一的线程修改变量的值（重排序的as-if-serial语义）
        + 变量不需要与其他的状态变量共同参与不变约束

    + 因为需要在本地代码中插入许多内存屏蔽指令在屏蔽特定条件下的重排序，volatile变量的写操作与读操作相比慢一些，但是其性能开销比锁低很多。
+ 线程间通信方式

+ 线程的各种状态
