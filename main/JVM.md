# Java虚拟机

+ ## <a href="https://github.com/wildhunt-unique/JavaKnowledgePoint/blob/master/README.md">返回概览</a>

+ ## JVM内存模型(基于jdk1.7)
    + ### 概念
        + JMM(Java Memory Model)，Java虚拟机在执行Java程序的过程会把它所管理的内存划分为若干不同的区域。这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机的启动而存在，有的区域则依赖用户线程的启动和结束来创建
    + ### JMM运行时数据区如图所示
    + ![Image text](http://www.qtu404.com/imageLib/github/20180625095148.png)
    + Java运行时数据区分为以下几个部分
        + 线程共享的部分
            + 方法区
            + 堆

        + 线程私有的部分
            + 虚拟机栈
            + 本地方法栈
            + 程序计数器

    + ### 程序计算器(Program Counter Register)
        + 程序计数器是一块较小的线程私有的内存空间，可以看作是当前线程锁执行的字节码的行号指示器。字节码解释器工作时，就参考这个数值来选取下一条执行的指令，分支、循环、跳转、异常处理、线程回复都等基础功能都要需要依赖这个计数器来完成。

        + Java通过线程轮换并分配处理器执行时间来实现多线程。因此，在一个确定的时刻，一个处理器都只会执行一条线程的指令。为了在切换线程之后，各线程都能恢复到正确的执行位置，每个线程都要需要一个独立的计数器。各个线程的计数器都互不影响，独立存储。为“线程私有”的内存。

        +  如果线程正在执行的是一个Java方法，记录的是正在执行的虚拟机字节码指令的地址

        +  如果执行的是Native方法，计数器值为空（Undefined）

        +  程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

    + ### Java虚拟机栈(Java Birtual Machine Stacks)
        + Java虚拟栈也是线程私有的内存。其生命周期与线程相同，虚拟栈描述的是**Java方法**执行的内存模型。每个方法在执行的时候，都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的调用、执行和结束，都对应着栈帧在虚拟机栈入栈、出栈的过程。

        + 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。
        
        + 当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。

        + 在规范中，此区域规定了两种异常。
            + 如果线程请求栈的深度大于虚拟机所允许的深度，则会抛出StackOverflowError异常
            + 如果栈可以动态扩展，当时扩展时，没有申请到足够的内存，就会抛出 OutOfMemoryError异常

    + ### 本地方法栈(Native Method Stack)
        + 与Java虚拟机栈功能相同，不同的是，Java虚拟机栈为虚拟机执行Java方法(.class字节码)服务，而本地方法栈为Native方法服务。什么是Native方法，自行百度JNI。

        + 值得注意的是，我们默认使用的JVM —— SunHotSpot，直接把 本地方法栈 和 Java虚拟机栈合二为一。同样会抛出StackOverflowError异常和OutOfMemoryError异常

    + ### Java堆(Java Heap)
        + Java堆是线程共享的区域，也是JMM中最大的一块。用于存放对象的实例以及数组，几乎所有的对象实例和数组都在堆这里分配。注意是几乎，而不是绝对。

        + 由于此区域存放对象的实例。因此，Java堆也是垃圾收集的主要区域。又由于现在的垃圾收集器都基于分代收集算法，所以Java堆还可以细分为新生代和老年代，再细致点，还可以向下再分为Eden空间、From Survivor空间、ToSurvivor空间等。关于这部分的详细知识，会在后面的GC部分详细描述。

        + 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。

    + ### 方法区(Medth Area)
        + 和堆一样，是各个线程共享的区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译的数据等。

        + Java虚拟机规范中将方法区作为堆的一个逻辑部分。 由于存放类的信息、常量、静态变量等数据，这些数据可能都是长时间驻存在内存中的，而且一个类是否应该被垃圾收集是不容易确认的，因此方法区中的数据不会轻易被垃圾收集。
        
        + 对于习惯在Hotspot虚拟机上编程的程序员来说，方法区还习惯被称“永久代”，但是这么说是有错误的。因为HopSpot只是用“永久代”来实现方法区
        
        + 运行时常量池(Runtime Constant Pool)是方法区的一部分。.class文件中除了了有类的字段、版本、方法、接口信息之外，还有一项信息是常量池(Constant Pool Table)。用于存放编译时期，生成的各种字面量(Literal)和符号引用(Symbolic References)。这部分的内容将在类加载后，进入方法区进行存放。

+ ## JVM类加载 
    + ### 加载机制
    + ### 双亲委派模型 

+ ## 垃圾收集器
     + ### 概念
        + GC(Garbage Collection)，垃圾回收器，简单来说，就是对象实例被使用完了之后，需要被从内存中清除，回收内存。为了完成GC，需要解决以下问题：
            + 哪些内存需要被回收
            + 什么时候回收
            + 怎么去回收
    
    + 哪些内存需要被回收
        + 判断对象是否需要被回收的算法
            + 引用计数器算法
                + 此算法根本不是JVM的判断算法。但是很多语言诸如python使用的是此算法。

                + 此算法给每一个对象都添加一个引用计数器。每当有一个地方引用它时，计数器加一。引用失效时，计数器减一。当计数器的值为0时，就认为该对象不再使用。

                + 这个算法看似简单而高效，但是却解决不了循环引用的问题。
        
            + 可达性分析算法
                + 主流商用语言如C#、Java用此算法判断对象是否需要被回收。
                + 这个算法的基本思路是通过一系列称为"GC roots"的对象作为起点，从这些起点向下搜索，搜索所走过的路径成为引用链，当一个对象到"GC roots"之间没有任何引用链，即表示此对象是不可用的。

                + 可作为GC roots的几种对象：
                    + 虚拟机栈（本地变量表中）中引用的对象
                    + 方法区中类静态属性引用的对象
                    + 方法区中常量引用对象
                    + 本地方法栈中的JNI引用的对象

                + 值得注意的是，即使在可达性分析算法中不可达的对象，也并不是立即被清除。对象在可达性分析之后，发现并没有与GC roots相连接的引用链，那么该对象就会被标记，并且进行一次筛选。筛选的条件是对象是否有必要执行`finalize()`方法，当对象没有重写`finalize()`或者对象已经执行过`finalize()`方法，虚拟机将认为没有必要执行该方法。

                + `finalize()`并不是一定会执行，因为执行此方法的线程级别很低

+ ## JVM优化
    + 可视化工具使用
    + 日志查询
    + 各项参数设置
    + 四种引用

+ ## 参考资料
    + > 深入理解Java虚拟机：JVM高级特性与最佳实践 / 周志明著 -2版-
    + > https://blog.csdn.net/xtayfjpk/article/details/41924283 深入理解Java虚拟机笔记---运行时栈帧结构
    + > http://liwenkun.me/2017/03/06/explore-java-vm-stack/ 探究 Java 虚拟机栈 Explore JVM Stack Posted by lwenkun on March 6, 2017